<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>ROAR &mdash; super scale chat for online crowds</title>
	
	<script src="/static/js/jquery-1.6.2.min.js" type="text/javascript"></script>
	<script src="/socket.io/socket.io.js"></script>
	<script src="/static/js/jquery.md5.js"></script>
	<script src="/static/js/underscore.js"></script>

	<script type="text/javascript" charset="utf-8">
		
		var socket = io.connect("http://<%= server %>:<%= port %>");
		var modelName = "<%=modelName%>";
		var rooms = [];
		var metaRooms = [];
		var Enabled = true;
		
		var usingDemoName = false;
		
		var pulseType = "river+y";
		var mostRecentSearchData;
		
		// Keeps a list of lists. Each entry is a chat message with a 
		// timestamp. 
		var messagesSent = [];
		
		
		var soccerKeyframes = [
		{"time":0, "level":0.4, "keywords":[null, null, null, "dive", "dive", "dive", "dive", "dive", "messi"]},
		{"time":15, "level":0.3, "keywords":[null, null, null, "dive", "dive", "dive", "messi", "messi", "messi", "messi"]},
		{"time":25, "level":0.2, "keywords":[null, null, null, "chelsea", "chelsea", "barca", "barca"]},
		{"time":34, "level":0.3, "keywords":[null, null, null, "torres", "torres", "messi", "messi"]},
		{"time":43, "level":0.2, "keywords":[null, null, null, "messi", "messi", "messi", "messi", "messi"]},
		{"time":48, "level":0.1, "keywords":[null, null, null, "messi", "messi", "kalou", "kalou"]},
		{"time":53, "level":1.0, "keywords":[null, "drogba", "drogba", "drogba"]},
		{"time":60, "level":1.0, "keywords":[null, "drogba", "drogba", "drogba", "drogba", "chelsea", "chelsea", "chelsea", "chelsea"]},
		{"time":72, "level":1.0, "keywords":[null, "drogba", "drogba", "mata", "mata", "mata", "chelsea", "chelsea", "chelsea"]},
		{"time":85, "level":0.6, "keywords":[null, "drogba", "drogba", "mata", "drogba", "drogba", "messi", "messi", "messi", "barca", "barca", "barca"]},
		{"time":130, "level":0.4, "keywords":[null, "drogba", "drogba", "mata", "drogba", "drogba", "chelsea", "chelsea", "chelsea"]},
		{"time":144, "level":0.6, "keywords":[null, "messi", "messi", "messi", "messi", "drogba", "chelsea", "chelsea", "chelsea"]},
		];
		
		var sc2KeyFrames = [
		{"time":0, "level":0.8, "keywords":[null, null, null, "nani", "nani", "naniwa", "thorzain", "thorzain", "thorzain", "thorzain"]}
		];
		
		var videoTypes = {
		"starcraft":{
			"src": "/static/vid/tsl3_final_moments.webm",
			"keyframes": sc2KeyFrames
		},
		"soccer":{
			"src":"/static/vid/chelsea_goal.webm",
			"keyframes": soccerKeyframes
		}};
		
		var keyframes;
		
		
		socket.on('connect', function(data) {
			console.log("Connected to server.");

			if("roar-username" in localStorage) {
				// This client has logged in before. Present auth to the 
				// server.

				socket.emit("identify", {username:localStorage["roar-username"]});

			} else {
				// This client has not logged in before. Present the identify
				// UI and ask them what they want their name to be. Then
				// send that to the server. 
				
				// in this demo version, if they haven't logged in, log them
				// in as a demo user. Need to randomize it a bit so they
				// don't collide.
				var curTimeString = Date.now() + '';
				var demoUserName = "Demo User " +
					curTimeString.slice(curTimeString.length-3,
					curTimeString.length);
					
				usingDemoName = true;
				
				socket.emit("identify", {username:demoUserName});
				
				//$("#identity-container").show();
			}
		});

		// Now we need to start listening for an identify response.
		socket.on('identify', _handleIdentityResponse);
		
		socket.on("chat", function (data) {
			appendChat(data);
		});
		
		// TODO I could merge this into the existing 'room' messages, but 
		// I'm lazy.
		socket.on("room-population", function(data) {
			$("#room-pop-value").text(data["population"]);
			sectionPop = data["population"];
		});
		
		socket.on('pulse', function (data) {
			
			// skip this if pulse is disabled. 
			if(!pulseEnabled) return;
			
			switch(pulseType) {
				case "cloud":
					updatePulseBigCloud(data);
					break;
				case "river+x":
					updatePulseRiver(data, "+x");
					break;
				case "river+y":
					updatePulseRiver(data, "+y");
					break;
				case "river+ym":
					updatePulseRiver(data, "+ym");
					break;
				case "bar":
					updatePulseBar(data);
					break;
			}
			
			// do the high level stats updating
			// var totalPopulation = data["total-population"];
			// $("#population").text(totalPopulation);
			
			// whichever mode we're in, attach listeners to every word
			// that causes a search.
			
			$("#pulse-container div").each(function(index, word) {
				
				word = $(word);
				
				if(word.attr("handled")=="true") return;
				
				word.click(function(event) {
					searchForKeyword($(this).text());
					
					// we also want to stop this word from moving, and slide
					// it to the left edge.
					word.stop();
					
					
					if(pulseType=="river+y") {
						// animate to the left edge? 
						
						word.addClass("held");
						
						word.animate({
							backgroundColor: "#444444",
							left: 5,
							zIndex: 1000000
						}, 300, "swing", function() {
							
							// once we're there, pull up the dialog
							// if it's available. 
							showSearchDialog($(this));
						});
					}
				});
				
				word.attr("handled", true);
			});
			
			$("#pulse").children()
		});
		
		socket.on('rooms', function(data) {
			rooms = data;
			
			// The rooms data is a list sorted by population. It also has lots
			// of sort of duplicate rooms. So we're going to do a first pass
			// to combine all those rooms and hide them. When you select one,
			// it'll just default to the '1' version of that room. 
			
			var condensedList = {};
			var totalPop = 0;
			for(var roomIndex in rooms) {
				var room = rooms[roomIndex];
				
				// split the room name on spaces. If the room is a number room
				// then merge it in.
				var roomPieces = room["name"].split(' ');
				var shortName;
				
				totalPop += parseInt(room.population);
				
				if(!isNaN(parseInt(roomPieces[roomPieces.length-1]))) {
					// Then the last 'word' is a number and we can collapse 
					// it into a group.
					var remainingPieces = roomPieces.slice(0,
						roomPieces.length-1);
					shortName = remainingPieces.join(" ");
					
					
					// default to the room number that we encounter first
					var currentMetaroom = {"name":room["name"], "population":0, "num_instances":0, "total_activity":0};
					if(shortName in condensedList) currentMetaroom =
						condensedList[shortName];
					
					currentMetaroom["population"] += 
						parseInt(room["population"]);
					currentMetaroom["num_instances"] += 1;
					currentMetaroom["total_activity"] += room["relative"];
					
					condensedList[shortName] = currentMetaroom;
				} else {
					// It's a normal room (probably user-defined) and we 
					// should treat it normally. include it in the main list.
					var shortName = roomPieces.join(" ");

					
					condensedList[shortName] = room;
					condensedList[shortName]["num_instances"] = 0;
					condensedList[shortName]["relative"] = room["relative"];
				}

			}

			// Now turn the metaroom hash into a list.
			var metaRoomList = [];
			for(var roomName in condensedList) {
				var metaRoom = condensedList[roomName];
				metaRoom["short_name"] = roomName;
				
				if(metaRoom["num_instances"]!=0) {
					metaRoom["relative"] = metaRoom["total_activity"]/
						metaRoom["num_instances"];
				}
				metaRoomList.push(metaRoom);
			}
			
			metaRoomList.sort(function(a, b) {
				return a["population"] - b["population"];
			});
			metaRoomList.reverse();
			metaRooms = metaRoomList;
			
			$("#top-rooms-list li").remove();
			
			// todo sort the rooms first
			var maxRooms = 8;
			for(roomIndex in metaRoomList) {
				var room = metaRoomList[roomIndex];
				
				// Make the room item element and append it immediately.
				makeRoomItemFromRoom(room).appendTo($("#top-rooms-list"));
				
				if($("#top-rooms-list").children().length==maxRooms) break;
			}
			
			// hardcode the four friend rooms in manually.
			$("#friends-rooms-list li").remove();
			_.each(["MIT", "reddit", "Google", "Cambridge"], function(roomName){
				var metaRoom = condensedList[roomName];
			
				// console.log("name: " + roomName + ", meta: " + JSON.stringify(metaRoom));
				makeRoomItemFromRoom(metaRoom).appendTo($("#friends-rooms-list"));
			});
			
			$("#population").text(totalPop);
			globalPop = totalPop;
		});
		
		socket.on('shout', function(data) {
			// Create a shout div.
			var shoutEl = $("<div></div>")
				.attr("id", "shout-" + data["id"])
				.addClass("shout")
				.append($("<div class='from'></div>").text(data["from"]))
				.append($("<div class='text'>" + data["text"] + "</div>"))
				.append($("<div class='votes-container'></div>")
					.append($("<div class='votes'>" + data["votes"]
						+ "</div>"))
					.append($("<div class='vote-button'>+1</div>")
						.attr("shout-id", data["id"])
						.click(function (event) {
							voteForShout($(this).attr("shout-id"));
							
							// Premeptively increment the value locally, so
							// there's clear local feedback and we don't need
							// to wait for confirmation from the server.
							// var voteCount=$(this).parent().children().first();
							// voteCount.text(parseInt(voteCount.text())+1);
							// (disabled for now - server responds super-fast, and that means we only have to validate on the server side.)
							
							$(this).addClass("disabled");
						})
						)
					)
				.append($("<br class='clear'>"))
				.appendTo($("#shout-live"));
				
				// Expire all shouts after a minute. This is a temporary thing
				// because bots keep them alive forever with infinite voting.
				setTimeout(function() {
					shoutEl.hide(200, function() {
						$(this).remove();
					});
				}, 60000);
		});
		
		socket.on('shout.vote', function(data) {
			// get the appropriate vote dom node and update it.
			$("#shout-" + data["id"] + " .votes").text(data["votes"]);
		});
		
		socket.on('shout.expire', function(data) {
			// TODO animate this.
			$("#shout-" + data["id"]).remove();
		});

		socket.on('bots', function(data) {
			// Just update the disabled status of the bots button.
			
			var buttonEl = $("#bots-mute");
			if(data["mute"]==true) {
				buttonEl.addClass("pressed");
				
			} else {
				buttonEl.removeClass("pressed");
				
				
			}
		});
		
		socket.on('search-result', function(data) {
			mostRecentSearchData = data;
			// just store it, and wait for the animation to finish to show it.
		});

		$(document).ready(function() {
			setPulseType("river+y");
			
			var isTested = false;
			if($.browser.safari || $.browser.webkit) {
				if(parseInt($.browser.version) >= 534) isTested = true;
			} else if($.browser.mozilla){
				if(parseInt($.browser.version[0]) >= 6) isTested = true;
			}
			
			if(!isTested) {
				alert("This prototype is only tested in recent versions of Chrome, Safari, and Firefox. Your browser is not supported and may fail in interesting (or boring) ways. Your mileage may vary! Future versions will hopefully have broader support. In any event, you can learn more about the project even if the demo itself doesn't work.");
			}
			
			// Setup default visibility.
			$("#identity-message").hide();
			$("#chat-history").hide();
			$("#rooms-container").hide();
			$("#chat-sect").hide();
			$("#sections-sect").hide();
			$("#pulse-sect").hide();

			
			$("#demo-header").hide();
			
			$(".callout").hide();
			
			$("#backdrop").show();
			$("#container").addClass("minimized");
			$("#container").offset({top:-424}, 0);
			
			$("#container").hide();
			
			$("#hide").text("about this project");
			
			$("#search-results").hide();
			
			$("#pulse h1").click(function() {
				// hide the pulse window
				
				// move to 50 less than the height of the window
				
				
				$("#pulse").animate({
					top: $("#pulse").height()-77
				}, 1000, "swing", function() {
					$("#pulse-container").empty();
				});
				pulseEnabled = false;
			});
			
			
			$(window).blur(function() {
				pulseEnabled = false;
			});
			
			$(window).focus(function() {
				pulseEnabled = true;
			});
			
			$("#bots-mute").click(function (event) {
				
				var mute = true;
				if($(this).is(".pressed")) {
					mute = false;
				}
				
				socket.emit("bots", {"mute":mute});
			});
			
			$("#chat-input").attr("disabled", true);
			
			// Setup event handlers.
			$("#chat-form").submit(sendChat);
			
			$("#chat-button").click(sendChat);
			$("#shout-button").click(sendShout);
			
			$("#submit-name").click(function(event) {
				socket.emit("identify", {username:$("#name").val()});
				event.preventDefault();
			});
			
			$("#nickname").click(function() {
				$("#nickname").hide();
				$("#identity-form").show();
				$("#name").removeClass("default-text");
				$("#name").removeClass("default-text-active");
				
				$("#name").val($("#nickname").html());
				
				$("#name-callout").hide(200);
				
				usingDemoName = false;
			});
			
			$("#show-history").click(function () {
				if($("#chat-history").is(":visible")) {
					// If it's visible, animate it to make it disappear.
					$("#chat-history").animate({bottom:-300}, 500, function(){
						$(this).hide();
					});
					$("#show-history").removeClass("pressed");
				} else {
					// First, clear out the live view so it doesn't get in
					// the way.
					$("#chat-live").children().remove();
					
					$("#chat-history").show();
					$("#chat-history").animate({bottom:51}, 500, null);
					$("#chat-history").scrollTop(Math.pow(2, 30));
					
					$("#show-history").addClass("pressed");
				}
			});
			
			$("#room-select-form").submit(function (event) {
				joinRoom($("#room").val());
				event.preventDefault();
			});
			
			$("#identity-form").submit(function (event) {
				socket.emit("identify", {username:$("#name").val()});
				event.preventDefault();
			})
			
			$("#room").keyup(function (event) {
				// grab the text in #room and see if it matches any of our
				// room names. If it does, add those on to the room menu.
				
				$("#suggested-rooms-list").children().remove();
				
				var baseString = $(this).val();
				var matchedRooms = getRelatedRoomsForString(baseString);
				
				var item;
				if(matchedRooms.length>0) {
					for(var roomIndex in matchedRooms) {
						var room = matchedRooms[roomIndex];
						
						item = makeRoomItemFromRoom(room);
					}
				} else {
					item = $("<li></li>")
						.text("No sections start with '" + baseString + "'");
				}
				
				item.appendTo($("#suggested-rooms-list"));
			});
			
			$("#room").focus(function (event) {
				// show the room list
				toggleRoomList(event);
			});
			
			$("#room").blur(function (event) {
				// hide the room list
				setTimeout(toggleRoomList, 50);
			});
			
			$(".section-button").click(function (event) {
				$(".selected").removeClass("selected");
				
				$("#content").children().hide();
				$("#" + this.id.split("-")[0] + "-sect").show();
				
				$(".callout").hide(200);
				
				switch(this.id.split("-")[0]) {
					case "overview":
						break;
					case "chat":
						$("#chat-callout").show(200);
						$("#bots-callout").show(200);
						break;
						
					case "sections":
						$("#section-callout").show(200);
						break;
					case "pulse":
						$("#pulse-callout").show(200);
						break;
					default:
						break;
				}
				
				$(this).addClass("selected");
			});
			
			
			$("#hide").click(hideInfoPanel);
			$("#backdrop").click(function(event) {
				if($("#container").is(".minimized")) {
					hideAllPanels();
				} else {
					hideInfoPanel(event);
				}
				$("#backdrop").hide();
			});
			
			// Manage default text.
			$(".default-text").focus(function(srcc)
		    {
		        if ($(this).val() == $(this)[0].title)
		        {
		            $(this).removeClass("default-text-active");
		            $(this).val("");
		        }
		    });

		    $(".default-text").blur(function()
		    {
		        if ($(this).val() == "")
		        {
		            $(this).addClass("default-text-active");
		            $(this).val($(this)[0].title);
		        }
		    });
			
		    $(".default-text").blur();
			
			
			// Setup the joining rooms click handlers
			$("#welcome table tr").click(function() {
				joinRoom($(this).attr("section"));
				$("#welcome").hide();
				$("#backdrop").hide();
			});
			
			$("#invite").hide();
			$("#invite-button").click(function() {
				$("#invite").show();
				$("#backdrop").show();
			});
			
			// setup the voting buttons. 
			$("#vote-left").click(handleVote);
			$("#vote-right").click(handleVote);
			
			
			$("#voting").hide();
			
			// setup the video stuff.
			keyframes = videoTypes[modelName].keyframes;
			
			$("#video").attr("src", videoTypes[modelName].src);
		});
		
		var sectionVotes = [0, 0];
		var globalVotes = [0, 0];
		var sectionPop = 100;
		var globalPop = 1000;
		
		var sectionVoteSplit = 0.5;
		var globalVoteSplit = 0.5;
		
		function handleVote() {
			var voteIndex = parseInt($(this).attr("voteIndex"));
			
			sectionVotes[voteIndex] = sectionVotes[voteIndex]+1;
			globalVotes[voteIndex] = globalVotes[voteIndex]+1;
			
			updateVoteBars();
		}
		
		function updateVoteBars() {
			$("#section-results .opt2").text(sectionVotes[1]);
			$("#section-results .opt1").text(sectionVotes[0]).css("width", (sectionVotes[0]/(sectionVotes[0]+sectionVotes[1]))*100 + "%");
			
			$("#global-results .opt2").text(globalVotes[1]);
			$("#global-results .opt1").text(globalVotes[0]).css("width", (globalVotes[0]/(globalVotes[0]+globalVotes[1]))*100 + "%");
		}
		
		function voteTick() {
			var split;
			var votesToEdit;
			
			var doneVoting = 0;
			
			if(sectionVotes[0] + sectionVotes[1] < sectionPop) {
				for(var i=0; i<Math.floor(sectionPop/30); i++) {
					sectionVotes = doVote(sectionVoteSplit, sectionVotes);
				}
			} else {
				doneVoting++;
			}
			
			
			if(globalVotes[0] + globalVotes[1] < globalPop) {
				for(var i=0; i<Math.floor(globalPop/30); i++) {
					globalVotes = doVote(globalVoteSplit, globalVotes);
				}
			} else {
				doneVoting++;
			}
			
			updateVoteBars();
			
			if(doneVoting==2) {
				
				// hide the panel after 10 seconds.
				setTimeout(function() {
					$("#voting").slideUp(500);
				}, 10000);
				
				return;
			}
			
			
			setTimeout(voteTick, 333);
		}
		
		function doVote(split, votes) {
			var rand = Math.random();
			if(rand < split) {
				votes[0]++;
			} else {
				votes[1]++;
			}
			
			return votes;
		}
		
		function setPulseType(type) {
			
			switch(type) {
				case "river+x":
					$("#pulse").css({
						position: "fixed",
						top: "auto",	
						bottom: 0,
						backgroundImage: "url('/static/img/inflicted.png')",
						width: "100%",
						height: 50,
						overflow: "hidden"
					});
					
					
					$("#roar-bar").css({
						bottom: 50
					});
					
					$("#chat-container").css({
						bottom: 100
					});
					
					$("#pulse").empty();
					
					$("#stream-img").css({
						width: "100%"
					});
					
					pulseType = type;
					break;
					
				case "river+y":
					// river y has the bar on the right side of the screen
					// $("#pulse").slideToggle();
					$("#pulse").css({
						position: "fixed",
						top: 0,	
						right: 0,
						backgroundImage: "url('/static/img/inflicted.png')",
						width: 200,
						height: "100%",
						overflow: "hidden",
						borderLeft: "1px solid #36464C"
					});

					$("#chat-container").css({
						bottom: 50
					});

					$("#roar-bar").css({
						bottom: 0
					});

					$("#pulse-container").empty();

					$("#stream-img").css({
						width: "85%"
					});
					
					// TODO if hidden, slide out. Figure this out when we
					// make the pulse draw show/hideable.
					$("#pulse").show();
					
					pulseType = type;
					break;
				case "river+ym":
					// this is the minimized version of the river viz
					
					$("#pulse").hide();
					$("#stream-img").css({
						width: "100%"
					});
					
					pulseType = type;
					pulseEnabled = true;
					break;
				
				case "bar":
					
					
					$("#pulse").css({
						position: "fixed",
						top: "auto",
						bottom: 0,
						backgroundImage: "url('/static/img/inflicted.png')",
						width: "100%",
						height: 50,
						overflow: "hidden",
						paddingTop: 10
					});
					
					$("#roar-bar").css({
						bottom: 50
					});
					
					$("#chat-container").css({
						bottom: 100
					});
					
					
					$("#pulse-container").empty();
					
					$("#stream-img").css({
						width: "100%"
					});
					
					
					pulseType = type;
					break;
					
				case "cloud":
					
					// Move the elements around to put pulse in the right
					// place.
					$("#pulse").css({
						position: "fixed",
						top: 0,
						left: 0,
						background: "rgba(1,1,1,0.0)",
						width: "100%",
						height: "100%"
					});
					
					$("#roar-bar").css({
						bottom: 0
					});
					
					$("#chat-container").css({
						bottom: 50
					});
					
					$("#stream-img").css({
						width: "100%"
					});
					
					$("#pulse-container").empty();
					
					pulseType = type;
					break;
				default:
					console.log("Bad pulse type given: " + type);
					break;
			}
		}
		
		function toggleRoomList(event) {
			if($("#rooms-container").is(":visible")) {
				$("#rooms-container").animate({bottom:-300}, 500, function(){
					$(this).hide();
				});
			} else {
				$("#rooms-container").show();
				$("#rooms-container").animate({bottom:51}, 500, null);
			}
		}
		
		function hideInfoPanel(event) {
			var hideEl = $("#hide");
			
			if($("#container").is(".minimized")) {
				$("#container").animate({
					top: "10px"
				}, 800, function() {
					$(this).removeClass("minimized");
					hideEl.text("hide");
					
					$("#backdrop").show();
				});
			} else {
				$(".callout").hide(200);
				$("#container").animate({
					top: -($("#container").height()-55)
				}, 800, function() {
					$(this).addClass("minimized");
					hideEl.text("about this project");

					
					if(usingDemoName) {
						$("#name-callout").show(200);
						
						// hide the callout in ten seconds if they don't
						// pick a new name.
						setTimeout(function() {
							$("#name-callout").hide(200);
						}, 10000);
					}
					
					
					$("#backdrop").hide();
				});
			}
			
			localStorage["roar-start-hidden"] = true;
		}
		
		function hideAllPanels(event) {
			$("#invite").hide();
			$("#welcome").hide();
			$("#search-results").hide();
			$(".held").each(function(i, el) {
				el = $(el)
				el.removeClass("held");
				updateRiverElement(el);
				animateRiverElement(el, "+y");
			});
		}
		
		function sendShout() {
			var chatTextElement = $("#chat-input");
			
			if(chatTextElement.val()=="") return;
			
			socket.emit("shout", {"text":chatTextElement.val()});
			chatTextElement.val("");
		}
		
		function voteForShout(shoutId) {
			socket.emit("shout.vote", {"shout_id":shoutId});
		}
		
		function sendChat(event) {
			var chatTextElement = $("#chat-input");
			
			if(chatTextElement.val() == "") {
				if(event!=null) event.preventDefault();
				return;
			}
			
			if(chatTextElement.val()=="/start") {
				chatTextElement.val("");
				startVideo();
				if(event!=null) event.preventDefault();
				return;
			}
			
			if (chatTextElement.val()=="/vote") {
				startVoting();
				chatTextElement.val("");
				if(event!=null) event.preventDefault();
				return;
			}
			
			if (chatTextElement.val()=="/login") {
				
				$("#welcome").show();
				$("#backdrop").show();
				
				chatTextElement.val("");
				if(event!=null) event.preventDefault();
				return;
			}
			
			
			socket.emit("chat", {"text":chatTextElement.val()});
			messagesSent.push({"text":chatTextElement.val(), "timestamp":new Date().getTime()});
			chatTextElement.val("");
			
			// reapply the recentWords to all current pieces of pulse.
			_.each(getRecentWordsUsed(), function(word) {
				var wordId = "#pulse-word-" + $.md5(word);
				
				var element = $(wordId);
				
				if(element.length) {
					element.addClass("usedRecently");
				}
				
			})
			
			
			if(event!=null) event.preventDefault();
		}
		
		function searchForKeyword(keyword) {
			socket.emit("search", {"keyword":keyword});
		}
		
		function getRecentWordsUsed() {
			// scream through messagesSent. Do a first pass filering for
			// recent messages. Save that back to messagesSent. That will
			// avoid it blowing up ver time. Then remove punctuation, split
			// on spaces, and get a list of unique words used locally.
			
			var recentMessages = [];
			var words = [];
			
			_.each(messagesSent, function(message) {
				var now = new Date().getTime();
				
				// words used in the last one minutes.
				if(now - message.timestamp < 1000*60*1) {
					recentMessages.push(message);
				}
				
				var text = message.text.replace(/[\(\)!?,.\"\'\*\=;]/g, " ");
		        text = text.replace(/\/\//g, " ");
				text = text.toLowerCase();
		        wordsInMessage = text.split(/[\s]+/);
		        
				words = _.union(words, wordsInMessage);
			});
			
			messagesSent = recentMessages;
			return words;
		}
		
		function appendChat(message) {
			
			// Make a normal message.
			classes = "";
			if("past" in message) classes += " past";
			
			if("admin" in message) classes += " admin";
			if("error" in message) classes += " error";
			
			 if(!("timestamp" in message)) {
			 	message.timestamp = Date.now();
			 }
			
			// We have two different versions because one of them (the
			// live one) gets expired and removed from the DOM. The other
			// one sticks around in a scrollable div for reviewing chat
			// history. They need different IDs to not collide.
			
			var hash = $.md5(message.timestamp + message.text);
			var liveId = 'chat-live-' + hash;
			var historyId = 'chat-' + hash;
			
			var contentsEl;
			if("admin" in message)  {
				contentsEl = $("<span class='contents'></span>");
				contentsEl.first().text(message.text);
			} else {
				contentsEl = $("<span class='from'></span>: <span class='contents'></span>");
				contentsEl.first().text(message.from);
				contentsEl.last().text(message.text);
			}
			
			var liveMessageEl = $("<div id='" + liveId + "' class='chat" + classes + "'></div>");
			liveMessageEl.append(contentsEl.clone());
			
			var historyMessageEl = $("<div id='" + historyId + "' class='chat" + classes + "'></div>");
			historyMessageEl.append(contentsEl.clone());
			
			// Append it. (is there a race condition here with removing elements? should I do this more formally with DOM operations?)
			chatHistory = $("#chat-history");
			chatHistory.append(historyMessageEl);
			
			// Scroll chat history down to the bottom.
			// INT_MAX. I want this to really represent the current height,
			// but I can't seem to find a property that represents the size 
			// that it really wants to be if there were no scrollbars to 
			// figure out how far down to push it. 
			chatHistory.scrollTop(Math.pow(2, 30));
			
			// Check and see if the history view is showing. If it is,
			// don't do live chat.
			if(!chatHistory.is(":visible")) {
				liveChat = $("#chat-live");
				liveChat.append(liveMessageEl);
			
				// This will remove each chat message from the list after 10 seconds and pull it out of the DOM entirely so the chat window area will manage its size automatically.
				setTimeout(function() {
					$("#chat-live-" + hash).animate({opacity:0.0}, 250, function() {
						$(this).remove();
					})
				}, 8000);
			}
		}
		
		function _handleIdentityResponse(data) {
			// this is called with repsonses to requests for a specific user
			// name. The server is either going to say "yes, you got it" or
			// "nope, that one is taken".
			if("state" in data && data["state"] == "OK") {
				// Start up the chat side of things.

				localStorage["roar-username"] = data["username"];

				$("#nickname").text(data["username"]);
				$("#nickname").show();
				
				$("#identity-form").hide();
				$("#chat-input").attr("disabled", false);
				$("#chat-input").focus();
				
				$(".button").removeClass("disabled");
				
				// Join a default room.
				// if(!data["rename"]) {
				// 	joinRoom("General Chat 1");
				// }
			} else if ("state" in data && data["state"] == "TAKEN") {
				// Stay in the same mode.
				localAdminMessage("'"+data["username"]+"' is taken.", true);
				$("#identity-message").show();
				$("#identity-form").show();
				$("#name").focus();
				$("#name").text(data["username"]);
			}
		}
		
		function joinRoom(roomName) {
			$("#room").val(roomName);
			socket.emit("room", {"name":roomName});
			$("#chat-input").focus();
		}
		
		var currentWords = {};
		
		var MAX_FONT_SIZE = 30;
		
		function updatePulseRiver(pulse, axis) {
			// make words appear on the left edge
			// set their size based on score
			// make them animate to the right, faster for smaller ones
			
			var pulseDiv;
			switch(axis) {
				case "+x":
				case "+y":
					pulseDiv = $("#pulse");
					$("#pulse-container").children().attr("untouched", "true");
					break;
				case "+ym":
					pulseDiv = $("#pulse-min");
					break;
			}
			
			pulseWords = pulse.words;
			pulseWords.sort(function(a, b) {
				return b["score"] - a["score"];
			});
			
			var wordCount = 0;
			// console.log("pulseWords: " + pulseWords.length);
			
			_.each(pulseWords, function(pulseItem) {
				wordCount++;
				
				if(axis=="+ym") {
					if(wordCount > 1) return;
				}
				
				if(wordCount > pulse.words.length*0.6) return;
				// check and see if the word already exists.
				var wordId = "pulse-word-" + $.md5(pulseItem["word"]);
				
				if($("#" + wordId).length) {
					
					// in minimized mode, we don't do any promotion of
					// existing words to avoid distraction. 
					if(axis=="+ym") return;
					
					// console.log("   found existing " + pulseItem["word"]);
					wordEl = $("#"+wordId);
					
					// now make it bigger and move slower
					
					var currentSize = parseInt(wordEl.css("font-size"));
					
					var newSize = currentSize;
					if(currentSize+2 < MAX_FONT_SIZE) {
						newSize = currentSize + 2;
						
						var initialWidth = wordEl.width();
						
						wordEl.css("font-size", newSize);
						
						
						// ADJUST POSITION TO MAINTAIN LOCATION
						// if we're doing x, this is top
						// if we're doing y, this is left
						
						switch(axis) {
							case "+x":
								var newYPos = parseInt(wordEl.css("top")) - 1;
								wordEl.css("top", newYPos);
								break;
							case "+y":
								var widthChange = wordEl.width()-initialWidth;
								
								var newXPos = parseInt(wordEl.css("left")) - widthChange/2;
								
								if(newXPos < 0) newXPos = 0;
								
								wordEl.css("left", newXPos);
								break;
						}
						

						updateRiverElement(wordEl);
						animateRiverElement(wordEl, axis);
						
						wordEl.removeAttr("untouched");
						
						
						currentWords[pulseItem["word"]] = currentWords[pulseItem["word"]]+1.5;
					}
					
					
				} else {
					// console.log("adding word: " + pulseItem["word"]);
					var newWord = $("<div class='pulseWordRiver'>" + pulseItem["word"] + "</div>");
					
					newWord.attr("id", wordId);
					
					currentWords[pulseItem["word"]] = Math.floor(pulseItem["score"]*2 + 2);
					
					var fontSize = 18*pulseItem["score"]+4;
					
					newWord.css("font-size", fontSize);
					
					
					var recentWords = getRecentWordsUsed();
					// console.log("word: " + pulseItem["word"] + " in " + JSON.stringify(recentWords) + "?");
					
					if(recentWords.indexOf(pulseItem["word"])!=-1) {
						console.log("adding used recently class for " + pulseItem["word"]);
						newWord.addClass("usedRecently");
					}
					
					
					// PUT THE WORD IN THE RIGHT PLACE AT THE START
					var size = getDimensionsForWord(pulseItem["word"], fontSize);

					var appendTarget;
					switch(axis) {
						case "+x":
							// for X, we do a random top position and a fixed
							// left position.
							newWord.css("top", Math.random()*(MAX_FONT_SIZE - MAX_FONT_SIZE*pulseItem["score"]));
							newWord.css("left", -1*size["width"]);
							appendTarget = $("#pulse-container");
							break;
						case "+y":
						case "+ym":
							// for y, we do a random left position and a
							// fixed top position.
							
							// we want to be somewhere between 0 and 
							// max-(width)
							var xPos = Math.random()*(pulseDiv.width() - size["width"]);
							newWord.css("left", xPos);
							newWord.css("bottom", -1*size["height"]);
							
							if(axis=="+y") appendTarget = $("#pulse-container");
							else appendTarget = $("#pulse-min");
					}
					
					updateRiverElement(newWord);
					
					
					newWord.appendTo(appendTarget);
					
					
					setTimeout(function() {
						animateRiverElement(newWord, axis);
					}, Math.random()*2500);
				}
			});
			
			$("#pulse-container").children().map(function () {
				var element = $(this);
			
				if(element.attr("untouched")!=null || element.attr("to-be-removed")) {
					
					// don't expire elements that are marked as
					// held. 
					
					currentWords[element.text()] = currentWords[element.text()]-1;
					
					if(currentWords[element.text()] < 1) {
						// just fade it.
						var that = this;
						
						if(element.hasClass("held")) {
							// don't expire this element yes, but mark as
							// to-be-expired in case we want to insta-expire
							// when the dialog is closed.
							element.attr("to-be-removed", true);
							return;
						}
						
						setTimeout(function() {
							$(that).stop();
							
							var animObj = {};
							switch(axis) {
								case "+x":
									animObj = {
										fontSize: 8,
										opacity: 0.0,
										left: "+=" + 100,
										top: "+=" + (parseInt($(that).css("fontSize"))-8)/2}
									break;
								case "+y":
									animObj = {
										opacity: 0.0,
										bottom: "+=" + 100
									};
									break;
							}
							
							$(that).animate(animObj, 1500, "linear", function() {
								$(that).remove();
								delete currentWords[$(that).text()];
							});
						}, 900*Math.random(), this);
					}
				}
			});
		}
		
		
		
		function showSearchDialog(element) {
			
			if(mostRecentSearchData==null) {
				// loop until it's available. but for now we'll just assume
				// response times are fast enough. 
				console.log("TRIED TO SHOW SEARCH RESULTS BUT NO RESULTS AVAIL");
			} 
			
			var messages = JSON.parse(mostRecentSearchData.messages);
			
			var resultsDiv = $("#search-results");
			resultsDiv.empty();
			
			// setup both the div itself and position it in the right place, 
			// e.g. next to the word you've selected.
			//
			// - make the header outside the scroll
			// - add an arrow on the side that's place appropriately to point
			//   at the selected word
			// - rounded corners
			
			
			var contents = $('\
			<div class="container">\
			<h1></h1>\
			<div class="total-messages"></div>\
			<div class="chat-container">\
			</div>\
			</div>\
			<div class="arrow"><b class="notch"></b>\
			</div>');
			
			resultsDiv.append(contents);
			
			$("#search-results h1").html(mostRecentSearchData.keyword + '<div id="close-search">x</div>');
			
			$("#close-search").click(function() {
				resultsDiv.slideUp();
				
				// now un-freeze the element.
				element.removeClass("held");
				updateRiverElement(element);
				animateRiverElement(element, "+y");
			});
			
			$("#search-results .total-messages").text(messages.length + " total messages.");
			
			_.each(messages, function(message) {
				
				var text = message.text;
				
				text = text.replace(mostRecentSearchData.keyword, "<span class='highlight'>" + mostRecentSearchData.keyword + "</span>");
				
				var chatDiv = $("<div class='chat'>" + text + "</div>");
				chatDiv.appendTo($("#search-results .chat-container"));
			});
			
			
			resultsDiv.css("right", 210);
			
			// now figure out where the element is. Our desire is to put the 
			// top of the search dialog aligned with the element and the
			// arrow at the top. We can do that anywhere except the bottom
			// 450 pixels of the screen. If we're in that mode, place the
			// search dialog at 450 and adjust the arrow down. 
			
			var elementPosition = parseInt(element.css("bottom")) + parseInt(element.css("font-size"))/2;
			var totalHeight = $("#pulse").height();
			
			console.log("elementPosition: " + elementPosition);
			
			if(elementPosition < 450) {
				resultsDiv.css("bottom", 60);
				$("#search-results .notch").css("top", 450-elementPosition-8);
				// adjust the arrow
			} else {
				resultsDiv.css("bottom", elementPosition - 362);
				$("#search-results .notch").css("top", 20);
			}
			
			resultsDiv.slideDown(500);
			
			// clear most recent search, since it's on screen now.
			mostRecentSearchData==null;
			$("#backdrop").show();
		}
		
		function updateRiverElement(element) {
			
			// don't touch elements that are "held" because they're currently
			// selected and should stick around.
			if(element.hasClass("held")) return;
			
			var fontSize = parseInt(element.css("font-size"));
			var scaled = fontSize / MAX_FONT_SIZE;
			
			// set transparency based on font size
			element.css("opacity", scaled*0.8 + 0.2);
			
			// set blur based on font-size
			if(fontSize < 14) {
				element.addClass("blur");
			} else {
				element.removeClass("blur");
			}
			
			// update z-index
			element.css("z-index", fontSize*10+100);
			
			// reset animation speed
		}
		
		function animateRiverElement(element, axis) {
			
			var size = parseInt(element.css("font-size"));
			
			var position;
			var maxPosition;
			var animatedSide;
			var animationTarget;
			
			switch(axis) {
				case "+x":
					maxPosition = $("#pulse").width();
					animatedSide = "left";
					animationTarget = {left:maxPosition};
					break;
				case "-x":
					maxPosition = $("#pulse").width();
					animatedSide = "right";
					animationTarget = {right:maxPosition};
					break;
				case "+y":
					maxPosition = $("#pulse").height();
					animatedSide = "bottom";
					animationTarget = {bottom:maxPosition};
					break;
				case "-y":
					maxPosition = $("#pulse").height();
					animatedSide = "top";
					animationTarget = {top:maxPosition};
					break;
				case "+ym":
					maxPosition = $("#pulse-min").height()*0.95;
					animatedSide = "bottom";
					animationTarget = {bottom:maxPosition, opacity:0.0};
					break;
				default:
					console.log("Bad axis selection: " + axis);
					break;
			}
			
			position = parseInt(element.css(animatedSide));
			
			// rate limit, and figure it based on actual pixel width
			// of the screen so different screen sizes don't have
			// different speeds.
			
			// max speed is going to be 30 px/s
			// min speed is going to be 5 px/s
			var pixelSpeed = 25 + 50*(1-(size/MAX_FONT_SIZE));
			
			// pixelSpeed = pixelSpeed + Math.random() * 30;
			// now convert to time
			var animationDuration = (maxPosition - position) / pixelSpeed;
			animationDuration = animationDuration*1000;
			
			// now do the actual animation
			element.stop();

			element.animate(animationTarget, animationDuration, "linear", function() {
				$(this).remove();
				delete currentWords[$(this).text()];
			});
		}
		
		function updatePulseBar(pulse) {
			// wipe the contents of #pulse and replace it with
			// new pulse words, sorted by score.
			var pulseDiv = $("#pulse");
			
			// console.log(pulse);
			// console.log("pulse words length: " + pulse.words.length);
			
			$("#pulse-container").empty();
			
			pulseWords = pulse.words;
			pulseWords.sort(function(a, b) {
				return b["score"] - a["score"];
			});
			
			var wordCount = 0;
			var currentXPos = 0;
			_.each(pulseWords, function(pulseItem) {
				wordCount++;
				
				if(wordCount > pulse.words.length*0.75) return;
				var newWord = $("<div class='pulseWordBar'>" + pulseItem["word"] + "</div>");
				newWord.css("font-size", 30*pulseItem["score"]);
				newWord.css("margin-top", -15*pulseItem["score"]);
				newWord.css("left", currentXPos);
				newWord.css("top", 25);
				newWord.appendTo($("#pulse-container"));
				
				currentXPos = currentXPos + newWord.width() + 5 + 5*pulseItem["score"];
				
				// console.log(pulseItem["word"] + " - " + pulseItem["score"]);
			});
		}
		
		// This function is the heart of the visualization system. Everytime
		// we receive a message from the server with aggregate data about
		// keywords across all rooms. Given the picture of the state, animate
		// from where it is now to where it needs to be. What this function
		// will receive is a list of word/score combos.
		function updatePulseBigCloud(pulse) {
			// if(!pulseEnabled) return;

			
			// Take the activity metrics and turn one into messages/min and
			// put it into the right place in the DOM.
			$("#messages-per-min").html(
				pulse["activity"]["messages-per-min-instant"]);

			// First pass: iterate through the pulse list and for each word
			// in the list, create a div that represents it in a random loc.
			
			
			// Set a dummy attribute on all the children of pulse. Remove it
			// when we touch them. If it's still there at the end, remove
			// the element.
			$("#pulse").children().attr("untouched", "true");
			
			// $("#pulse").children().attr("untouched", "true");
			
			var pulseWords = pulse["words"];
			for(var itemIndex in pulseWords) {
				var pulseItem = pulseWords[itemIndex];
				var pulseWord = pulseItem["word"];
				
				// Runs 0->1
				var pulseMagnitude = pulseItem["score"];
				
				if(pulseWord=="") continue;
				
				// TODO change this to a hash so we can deal with words
				// that aren't legal CSS ids
				var wordId = "pulse-word-" + $.md5(pulseWord);
				
				// words are always created at 0.5 opacity if they're not
				// blurry. then, over time if they persist they gain opacity.
				var newOpacity = 0.3;
				
				// If the word already exists, find that element and update it
				// Otherwise, create a new one.
				var wordEl;
				if($("#" + wordId).length) {
					wordEl = $("#"+wordId);
					
					// If the word already exists, update its size.
					// (the extra -6 is to make sure that words still have
					//  some downward presure on their size over time even
					//  if they're getting a few points still)
					var size = pulseMagnitude*24;
					var newSize = parseInt(wordEl.css("font-size")) + size
						- 8;

					if(!isBlur && wordEl.hasClass("blur")) {
						// fix it up and make it workable.
						wordEl.removeClass("blur");
					} else if(!wordEl.hasClass("blur") &&
						newSize < 16) {
						// make it blur!
						wordEl.addClass("blur");
					}
					
					var newDimensions = getDimensionsForWord(
						wordEl.html(), newSize);
					
					// To make it look like it's growing equally in either
					// direction (instead of growing from the upper left 
					// corner), figure out how much larger it'll be after
					// growth and move left half of the difference.
					var leftDelta=(wordEl.width()-newDimensions["width"])/2;
					var topDelta=(wordEl.height()-newDimensions["height"])/2;
					
					wordEl.animate({
						fontSize: newSize,
						opacity: "+=" + 0.1,
						left: "+=" + leftDelta,
						top: "+=" + topDelta,
					}, 250, "linear", function() {
						
						// I feel like I should do this here, but when I do
						// I get weird behavior. Hmm.
							// if(newSize < 5) $(this).remove();
					});
					
					wordEl.removeAttr("untouched");
					
				} else {
					// If the word isn't on screen already, add it.
					
					var topPos = Math.random()*($(window).height()*0.3)
						+ $(window).height()*0.7;
					var leftPos = Math.random()*($(window).width()*0.65)
						+ $(window).width()*0.35;
					
					// the max size should be 2.25 with a pulse ranging from 
					// 0 - 1, but this puts stuff off the bottom edge at that
					// value, so upping it.
					var maxDimensions = getDimensionsForWord(pulseWord, 4);
					if(leftPos + maxDimensions["width"] > $(window).width()) {
						leftPos -= leftPos + maxDimensions["width"] - $(window).width();
					}
					
					if(topPos + maxDimensions["height"] > ($(window).height())) {
						topPos -= topPos + maxDimensions["height"] - $(window).height();
						
						// console.log("want to adjust top - " + (topPos + maxDimensions["height"] - $(window).height()));
					}
					
					
					wordEl = $(document.createElement('div'));
					wordEl.attr("id", wordId);
					wordEl.css("top", topPos);
					wordEl.css("left", leftPos);
					wordEl.addClass("pulseWordCloud");
					wordEl.html(pulseWord);
					
					var size = pulseMagnitude*2*12;
					
					var isBlur = false;
					if(size < 16) {
						isBlur = true;
					}
					
					if(isBlur) {
						
						// if it's blur, create it as blurry
						wordEl.css("font-size", 16);
						wordEl.css("opacity", 0.0);
						wordEl.addClass("blur");

						$("#pulse").append(wordEl);
						
						wordEl.animate({
							opacity: 0.5
						}, 500, "linear", null);
						
					} else {

						// Create the element with default settings so it's
						// invisible but in the right place, then animate
						// it to the right size and opacity.
						wordEl.css("opacity", 0.0);
						wordEl.css("font-size", 4);
						$("#pulse").append(wordEl);
					
						var newDimensions = getDimensionsForWord(
							wordEl.html(),size);
						var leftDelta =
						 	(wordEl.width()-newDimensions["width"])/2;
						var topDelta =
							(wordEl.height()-newDimensions["height"])/2;
					
						wordEl.animate({
							opacity: newOpacity,
							fontSize: size,
							left: "+=" + leftDelta,
							top: "+=" + topDelta
						}, 500, "linear", null);
					}
					
					wordEl.css("z-index", parseInt(wordEl.css('font-size')));
				}
			}
			
			
			// Now cycle through all the elements in pulse and remove any
			// that haven't been touched - those have no magnitude
			// otherwise they would have been in the update list.
			var pulseWordEls = $("#pulse").children();
			// console.log("untouched words: ", pulseWordEls);
			
			pulseWordEls.map(function () {
				var element = $(this);

				if(element.attr("untouched")!=null) {
					// console.log("found one");
					// If the element still has the untouched attribute,
					// nuke it.
					
					// we're going to shrink by a fixed amount. Call it 5px 
					// for now.
					var newSize = parseInt(element.css("font-size")) - 8;

					var newDimensions = getDimensionsForWord(element.html(), newSize);
					var leftDelta=(element.width()-newDimensions["width"])/2;
					var topDelta=(element.height()-newDimensions["height"])/2;

					if(newSize < 16) {
						element.addClass("blur");
					}
					
					// clamp it because at small sizes you get weird behavior.
					if(newSize < 6) {
						newSize = 6;
					}

					// TODO come back to opacity and fix it. 
					element.animate({
						// opacity: 0.0,
						fontSize: newSize,
						left: "+=" + leftDelta,
						top: "+=" + topDelta
					}, 250, function() {
						if(newSize <= 6) $(this).remove();
					});
				}
			});
		 }
		
		// Used to generate local error messages into the chat logs.
		function localAdminMessage(message, isError) {
			var msgDict = {text:message, admin:"true", error:isError};
			appendChat(msgDict);
		}
		
		function getDimensionsForWord(word, size) {
			var buffer = $("#word-buffer");
			buffer.html(word);
			buffer.css("font-size", size);
			var size = {"width":buffer.width(), "height":buffer.height()};
			buffer.html("");
			return size;
		}
		
		function getRelatedRoomsForString(string) {
			// Given a string, loop through the room list and return a list of
			// any rooms that START with that string. This isn't super fancy,
			// but whatever. It's easy and will look okay in a demo.
			
			var candidateMetaRooms = [];
			
			if(string=="") return candidateMetaRooms;
			
			for (var roomIndex in metaRooms) {
				var room = metaRooms[roomIndex];
				
				var result = room["short_name"].toLowerCase().search(
					string.toLowerCase());
				//var resultName = room["name"].toLowerCase().search(string);
				
				if (result>-1) {
					candidateMetaRooms.push(room);
				}
			}
			
			return candidateMetaRooms;
		}
		
		function makeRoomItemFromRoom(room) {
			
			var roomName = room.name;
			var roomPop = room.population;
			

			var roomItem = $("<li></li>")
				.attr("title", room["name"])
				.click(function (event) {
					$("#room").val($(this).attr("title"));
					$("#room-select-form").submit();
				});

			var roomActivityIndicator = $("<div></div>")
				.addClass("activity")
				.appendTo(roomItem);
				
			// rescale relativeLevel (which runs approx 0-2) to 1-5.
			var relativeLevel = Math.floor(5*(room["relative"]/2));
			if(relativeLevel>5) relativeLevel = 5;
			
			var colorClass;
			switch(relativeLevel) {
				case 0:
					colorClass = "level-red";
					break;
				case 1:
				case 2:
					colorClass = "level-yellow";
					break;
				case 3:
				case 4:
					colorClass = "level-green";
					break;
				default:
					colorClass = "level-green";
			}
			for(var i=0; i<5; i++) {
				var activityPixel = $("<div></div>")
					.addClass("pixel")
					.appendTo(roomActivityIndicator);
				
				if(i<relativeLevel+1) activityPixel.addClass(colorClass);
			}

			
			var roomName = $("<div></div>");
			roomName.text(room.name + " ("+room.population+")")
				.appendTo(roomItem);
				
			if(room["num_instances"]!=0) {
				roomName.text(room.short_name + " ("+room.population+"/"+room.num_instances+")");
			}
			
			
			return roomItem;
		}
		
		
		function startVoting() {
			// show the voting screen. 
			$("#voting").slideDown(500);
			// $("#voting").show();
			
			// set defaults
			globalVoteSplit = Math.random();
			sectionVoteSplit = globalVoteSplit + (Math.random()*0.5 - 0.5);
			
			sectionVotes = [0, 0];
			globalVotes = [0, 0];
			
			
			// kick off voting.
			voteTick();
		}
		
		function setStream(streamId) {
			
			if(streamId==null) {
				// put the image back in.
				$("#stream-img").show();
				$("#live_embed_player_flash").remove();
			} else {
				
				var stream
				
				var streamObj = $('<object type="application/x-shockwave-flash" height="90%" width="100%" style="position:fixed; top: 20px" id="live_embed_player_flash" data="http://www.twitch.tv/widgets/live_embed_player.swf?channel='+streamId+'" bgcolor="#000000"><param name="allowFullScreen" value="true" /><param name="allowScriptAccess" value="always" /><param name="allowNetworking" value="all" /><param name="movie" value="http://www.twitch.tv/widgets/live_embed_player.swf" /><param name="wmode" value="opaque" /><param name="flashvars" value="hostname=www.twitch.tv&channel='+streamId+'&auto_play=true&start_volume=25" /></object>').appendTo($("body"));
				
				$("#stream-img").hide();
			}
		}
		
		var frameIndex = 0;
		
		function startVideo() {
			
			$("#container").hide();
			var videoEl = document.getElementById("video");
			
			console.log("STARTING VIDEO");
			
			frameIndex = 0;
			videoEl.currentTime = 0;
			videoEl.play();
			
			videoTic();
		}
		
		function videoTic() {
			var videoEl = document.getElementById("soccer_video");

			// console.log("time: " + videoEl.currentTime);
			var currentFrame = keywordKeyFrames[frameIndex];
			
			if(videoEl.currentTime > currentFrame.time) {
				console.log("frame: " + JSON.stringify(currentFrame));
				//send the data to th server.
				socket.emit("keyframe", currentFrame);
				
				frameIndex++;
			}
			
			// drop out of the process if we're at the end.
			if(frameIndex==keywordKeyFrames.length) {
				$("#container").show();
				
				return;
			}
			
			setTimeout(videoTic, 1000);
		}
		
	</script>

	<link rel="stylesheet" href="/static/css/roar.css" type="text/css" media="screen" charset="utf-8">
	<link rel="stylesheet" href="/static/css/css-social-buttons/zocial.css" type="text/css" media="screen" charset="utf-8">

	
</head>
<body>


<div id="demo-header">
<div class="title">ROAR</div><div class="subtitle">super scale chat for online crowds</div><div class="byline"> Drew Harry, Speech + Mobility</div>
</div>

<video id='video'></video>

<div id="container">
	<div id="information">
		<div id="header-container">
			<img id="images" src="/static/img/sc2-audience.jpg">
			<div id="text">
				<div id="header">
					<h1>ROAR</h1>
					<h2>super scale chat for online crowds</h2>
				</div>
				<div id="overview-title" class="section-button selected">
					overview
				</div>
				<div id="chat-title" class="section-button">
					chat &amp; shouts
				</div>
				<div id="sections-title" class="section-button">
					sections
				</div>
				<div id="pulse-title" class="section-button">
					pulse
				</div>
			</div>
			<br class="clear">
		</div>
		<div id="content">
			<div id="overview-sect">
<p>The experience of being in a crowd is visceral. We feel a sense of connection and belonging through shared experiences like watching a sporting event, speech, or performance. In online environments, though, we are often part of a crowd without feeling it. <span class="roar">ROAR</span> is designed to allow very large groups of distributed spectators have <span class="highlight">meaningful conversations</span> with strangers or friends while creating a <span class="highlight">sense of presence</span> of thousands of other spectators. <span class="roar">ROAR</span> is also interested in creating opportunities for <span class="highlight">collective action</span> among spectators and providing flexible ways to share content among very large groups. These systems combine to let you feel the roar of the crowd even if you're alone in your bedroom.</p>
	
<p>This is an <b>early prototype</b> and is not tested in anything other than the very latest WebKit-based browsers like <i>Safari</i> or <i>Chrome</i>.</p>
			</div>
			<div id="chat-sect">
				At its heart, <span class="roar">ROAR</span> is about chat. You can send two different kinds of text-based messages. Like a normal chat system, you can send <span class="highlight">chat</span> messages to other people in your section of the crowd. These messages rapidly expire, but you can send them as often as you like. <span class="highlight">Shouts</span>, on the other hand, have a life of their own. When you shout something, everyone in your section sees it first and if enough of them like it (by clicking '+1') people in other sections will see it too. 
			</div>
			<div id="sections-sect">
				<span class="highlight">Sections</span> in <span class="roar">ROAR</span> are your way of deciding what kind of chat experience you want to have. Sections can be named anything you want&mdash;you can make your own section by just typing in any name you like. All sections are public, but only the most popular sections are shown in the suggested list, so you can make a section for just you and your friends if you like. Suggested sections all have a small activity indicator to help you gauge how active that section is; the more dots, the more chatting going on there. 
			</div>
			<div id="pulse-sect">
				Pulse is what really brings the crowd together in <span class="roar">ROAR</span>. The words you see bubbling up below are the <span class="highlight">most common recent terms across <emph>all</emph> sections</span>. The more words there are, the more active the crowd is; when there are very few words, the crowd has gone silent. Well-coordinated crowds can manipulate this display by coordinating common outbursts (perhaps using the shout feature) to force the system to display their chosen words. 
			</div>
		</div>
	</div>
	<div id="footer">
		<a href="http://roar.media.mit.edu/">ROAR</a> was designed at the <a href="http://mit.edu">MIT</a> <a href="http://media.mit.edu/">Media Lab</a> by <a href="http://web.media.mit.edu/~dharry/">Drew Harry</a> with the <a href="http://media.mit.edu/speech/">Speech + Mobility Group</a>
	</div>	
	<div id="hide">
		hide
	</div>
</div>

<div id="backdrop">
</div>

<div id="welcome" class="overlay">
<h1>Welcome to ROAR!</h1>
<h2>Sections with Friends</h2>
<table border="0">
	<tr section="MIT"><td class="pop">52</td><td>MIT</td><td><img src="/static/img/fb/1.jpg"><img src="/static/img/fb/2.jpg"><img src="/static/img/fb/3.jpg"><img src="/static/img/fb/4.jpg"><img src="/static/img/fb/5.jpg"> ... and 6 more</td></tr>
	<tr section="Chelsea 3"><td class="pop">1534</td><td>Chelsea 3</td><td><img src="/static/img/fb/6.jpg"><img src="/static/img/fb/7.jpg"></td></tr>
	<tr section="Google"><td class="pop">178</td><td>Google</td><td><img src="/static/img/fb/8.jpg"></td></tr>
	<tr section="Andrea"><td class="pop">1</td><td>Andrea's Section</td><td><img src="/static/img/fb/9.jpg"></td></tr>
</table>
<!-- Start with a facebook/twitter login icon. -->
<!-- Swap in a list of sections with join buttons later. -->

<h2>Popular Sections</h2>
<table border="0" cellspacing="5" cellpadding="5">
	<tr section="Barcelona 1"><td class="pop">1534</td><td>Barcelona</td></tr>
	<tr section="Chelsea 1"><td class="pop">1390</td><td>Chelsea</td></tr>
	<tr section="reddit 1"><td class="pop">1273</td><td>reddit</td></tr>
	<tr section="Reds 1"><td class="pop">1198</td><td>Reds</td></tr>
</table>
</div>

<div id="invite" class="overlay">
<h1>Invite friends</h1>
<p>Share this link to invite a friend to come watch with you.</p>
<form id="room-select-form">
<label for="invite-link">invite link</label><input type="text" name="invite-label" value="http://roar.media.mit.edu/invite?key=ac9b28f1h0ad2" id="invite-link">
<div class="btn">copy</div>
</form>
<br class="clear">
<p>You can automatically invite your friends on any of these social network sites.</p>

<div class="sharing">
<div class="zocial facebook icon"></div><div class="zocial twitter icon"></div>
</div>
</div>


<div id="voting">
<div id="vote-left" class="vote-button btn btn-red" voteIndex="0">Barca Scores</div>
<div id="results">
<div id="section-results" class="results-container"><div class="opt2">0</div><div class="opt1 bar">0</div></div>
<div id="global-results" class="results-container"><div class="opt2">0</div><div class="opt1 bar">0</div></div>
<br class="clear">
</div>
<div id="vote-right" class="vote-button btn btn-blue" voteIndex="1">Chelsea Scores</div>
</div>


<div class="callout border-callout" id="name-callout">
	You can <span class="highlight">change your nickname</span> by clicking here and entering a new one.
    <b class="border-notch left"></b>
    <b class="notch left"></b>
</div>

<div class="callout border-callout" id="chat-callout">
	<span class="highlight">Type your message here!</span> If you press "chat" (or hit return) the message will go to your section. If you press "shout", the message will start in your section and if enough people vote for it it will spread to other sections. Use the buttons to the right of the chat box to see chat history and mute/unmute the bots.
    <b class="border-notch left"></b>
    <b class="notch left"></b>
</div>

<div class="callout border-callout" id="section-callout">
	Use this to <span class="highlight">choose which section</span> of the crowd you want to be in. You can choose an existing section or type in the name of your own custom section. A pop-up window will show you which sections have the most people and how active they are.
    <b class="border-notch right"></b>
    <b class="notch right"></b>
</div>


<div class="callout border-callout" id="bots-callout">
	This <span class="highlight">chat is coming from bots</span> trained to talk about live Starcraft 2 matches. It can be a little incoherent (and occasionally a bit rude) but it's a nice way to test the visualization with real content. 
    <b class="border-notch left"></b>
    <b class="notch left"></b>
</div>

<div class="callout border-callout" id="pulse-callout">
	This is the pulse visualization area. The words shown here are the <span class="highlight">most popular terms across <emph>all</emph> sections</span>. The more words visible, the more active the crowd is right now. The more solid the word, the longer it has been visible.
    <b class="border-notch right"></b>
    <b class="notch right"></b>
</div>

<div id="roar-container">
<div id="roar-bar">
<div id="logo">ROAR</div>

<div id="chat-container">
<div id="chat-live">
</div>
<div id="shout-live">
</div>
</div>

<div id="identity">
	<div id="nickname"></div>
	<form id="identity-form">
		<input type="text" name="name" title="your nickname?" value="" id="name"class="default-text">
		<input type="button" name="submit_name" value="login" id="submit-name"><br>
	</form>
</div>

<div id="chat">
<form id="chat-form">
	<input type="text" name="chat-input" title="say something!" value="" id="chat-input" class="default-text" autocomplete="off">
	<div id="show-history" class="toggle-button" title="Toggle history panel"></div>
	<div id="bots-mute" class="toggle-button" title="Mute/unmute bots"></div>
</form>


</div>
<div id="chat-button" class="button disabled">
chat
</div>
<div id="shout-button" class="button disabled">
shout
</div>

<div id="chat-history">
</div>






<div id="rooms-container">
<h1>top sections</h1>
<ul id="top-rooms-list"></ul>
<h1>friends' sections</h1>
<ul id="friends-rooms-list"></ul>
<h1>search results</h1>
<ul id="suggested-rooms-list"></ul>
</div>



<div id="stats">
<div id="population">
<canvas></canvas>
</div>
</div>

<div id="room-select">
<form id="room-select-form">
<label for="room">section</label><input type="text" name="room" value="" id="room">
</form>
<div id="room-population"><span id="room-pop-value"></span></div>
<div id="lock"></div>
<button id="invite-button">invite</button>
</div>


<div id="pulse">
<h1>PULSE</h1>
<div id="pulse-container">
</div>
</div>

<div id="pulse-min">
</div>

<div id="word-buffer">
</div>

<div id="search-results">
</div>



</div>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-841537-6']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>

